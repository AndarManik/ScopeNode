<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>WebGL Mouse Warp Demo (Fixed Y + Stronger Warp)</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0b0f14;
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      #wrap {
        position: fixed;
        inset: 0;
      }
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      #hud {
        position: absolute;
        left: 12px;
        top: 12px;
        padding: 10px 12px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        color: rgba(255, 255, 255, 0.85);
        font-size: 13px;
        line-height: 1.35;
        user-select: none;
        pointer-events: none;
        backdrop-filter: blur(6px);
      }
      #hud b {
        color: rgba(255, 255, 255, 0.95);
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="gl"></canvas>
      <div id="hud">
        <div><b>Mouse Warp Demo</b> (WebGL shader)</div>
        <div>Move mouse to warp. Scroll: radius. Shift+Scroll: strength.</div>
        <div id="readout"></div>
      </div>
    </div>

    <script>
      // ============================================================
      // DROP-IN (fixed Y + more dramatic warp)
      //
      // Changes vs prior version:
      //  1) Fix Y inversion: gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)
      //  2) Stronger warp defaults + higher clamp range
      //  3) More dramatic falloff: rational (long-tail) instead of Gaussian
      // ============================================================

      const glCanvas = document.getElementById("gl");
      const gl = glCanvas.getContext("webgl", {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
      });

      if (!gl) {
        document.body.innerHTML =
          "<pre style='color:#fff;padding:16px'>WebGL not available.</pre>";
        throw new Error("WebGL not available");
      }

      // Offscreen 2D canvas for scene
      const scene = document.createElement("canvas");
      const ctx = scene.getContext("2d", { alpha: false });

      // Mouse state (in backing pixels)
      const mouse = { x: 0, y: 0, has: false };

      // Warp params (in pixels) â€” stronger defaults
      let sigmaPx = 170; // radius of influence
      let ampPx = 40; // max displacement in pixels (dramatic)

      // Random circles scene state
      const circles = [];
      const CIRCLE_COUNT = 220;

      function rand(min, max) {
        return min + Math.random() * (max - min);
      }

      function makeCircles() {
        circles.length = 0;
        for (let i = 0; i < CIRCLE_COUNT; i++) {
          circles.push({
            x: Math.random(),
            y: Math.random(),
            r: rand(6, 42),
            hue: rand(0, 360),
            a: rand(0.25, 0.9),
          });
        }
      }
      makeCircles();

      // ============================================================
      // WebGL helpers
      // ============================================================
      function compileShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          const msg = gl.getShaderInfoLog(s);
          gl.deleteShader(s);
          throw new Error(msg);
        }
        return s;
      }

      function makeProgram(vsSrc, fsSrc) {
        const p = gl.createProgram();
        gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fsSrc));
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          const msg = gl.getProgramInfoLog(p);
          gl.deleteProgram(p);
          throw new Error(msg);
        }
        return p;
      }

      function makeFullscreenQuad() {
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([
            -1, -1, 1, -1, -1, 1, // tri 1
            -1, 1, 1, -1, 1, 1, // tri 2
          ]),
          gl.STATIC_DRAW
        );
        return buf;
      }

      // ============================================================
      // Shaders
      // ============================================================
      const VS = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main() {
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

      // More dramatic warp: rational falloff (longer tail) instead of Gaussian.
      // Also includes a mild "center punch" via pow().
      const FS = `
precision mediump float;

uniform sampler2D u_scene;
uniform vec2 u_resolution;   // backing-pixel resolution
uniform vec2 u_mousePx;      // mouse in backing pixels
uniform float u_ampPx;       // displacement amplitude in pixels
uniform float u_sigmaPx;     // falloff radius in pixels
uniform float u_enabled;     // 0/1

varying vec2 v_uv;

void main() {
  vec2 pPx = v_uv * u_resolution;

  if (u_enabled < 0.5) {
    gl_FragColor = texture2D(u_scene, v_uv);
    return;
  }

  vec2 r = pPx - u_mousePx;
  float d2 = dot(r, r);
  float d = sqrt(d2) + 1e-6;

  // Long-tail falloff: g = A * (s^2 / (d^2 + s^2))
  float s2 = u_sigmaPx * u_sigmaPx;
  float base = s2 / (d2 + s2);

  // Optional: "punch" the center slightly (lower exponent spreads, higher tightens)
  float shaped = pow(base, 0.85);

  float g = u_ampPx * shaped;

  vec2 u = r / d;

  // Inverse warp sample (good approximation for this effect)
  vec2 srcPx = pPx - u * g;
  vec2 srcUv = clamp(srcPx / u_resolution, vec2(0.0), vec2(1.0));

  gl_FragColor = texture2D(u_scene, srcUv);
}
`;

      const prog = makeProgram(VS, FS);
      const quad = makeFullscreenQuad();

      const a_pos = gl.getAttribLocation(prog, "a_pos");
      const u_scene = gl.getUniformLocation(prog, "u_scene");
      const u_resolution = gl.getUniformLocation(prog, "u_resolution");
      const u_mousePx = gl.getUniformLocation(prog, "u_mousePx");
      const u_ampPx = gl.getUniformLocation(prog, "u_ampPx");
      const u_sigmaPx = gl.getUniformLocation(prog, "u_sigmaPx");
      const u_enabled = gl.getUniformLocation(prog, "u_enabled");

      // Scene texture
      const sceneTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, sceneTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // FIX Y-INVERSION: flip rows when uploading the 2D canvas into the texture
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      // ============================================================
      // Resize handling (DPR-correct)
      // ============================================================
      function resize() {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const cssW = glCanvas.clientWidth || window.innerWidth;
        const cssH = glCanvas.clientHeight || window.innerHeight;

        const w = Math.max(1, Math.floor(cssW * dpr));
        const h = Math.max(1, Math.floor(cssH * dpr));

        if (glCanvas.width !== w || glCanvas.height !== h) {
          glCanvas.width = w;
          glCanvas.height = h;
          gl.viewport(0, 0, w, h);

          scene.width = w;
          scene.height = h;
        }
      }

      window.addEventListener("resize", resize, { passive: true });
      resize();

      // ============================================================
      // Input
      // ============================================================
      function updateMouseFromEvent(e) {
        const rect = glCanvas.getBoundingClientRect();
        const sx = glCanvas.width / rect.width;
        const sy = glCanvas.height / rect.height;
        mouse.x = (e.clientX - rect.left) * sx;
        mouse.y = (e.clientY - rect.top) * sy;
        mouse.has = true;
      }

      glCanvas.addEventListener("mousemove", updateMouseFromEvent, {
        passive: true,
      });
      glCanvas.addEventListener(
        "mouseleave",
        () => {
          mouse.has = false;
        },
        { passive: true }
      );
      glCanvas.addEventListener("mouseenter", updateMouseFromEvent, {
        passive: true,
      });

      // Scroll: radius. Shift+Scroll: strength. (higher clamps)
      window.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const delta = Math.sign(e.deltaY);

          if (e.shiftKey) {
            ampPx = Math.max(0, Math.min(220, ampPx + delta * 6));
          } else {
            sigmaPx = Math.max(20, Math.min(900, sigmaPx + delta * 14));
          }
        },
        { passive: false }
      );

      // Click to re-randomize circles
      window.addEventListener(
        "mousedown",
        () => {
          makeCircles();
        },
        { passive: true }
      );

      // ============================================================
      // Scene drawing (random circles)
      // ============================================================
      const readout = document.getElementById("readout");

      function drawScene2D(timeMs) {
        const w = scene.width;
        const h = scene.height;

        ctx.fillStyle = "#0b0f14";
        ctx.fillRect(0, 0, w, h);

        // Subtle grid
        ctx.globalAlpha = 0.12;
        ctx.strokeStyle = "#9fb3c8";
        ctx.lineWidth = 1;
        const step = Math.max(32, Math.floor(Math.min(w, h) / 18));
        ctx.beginPath();
        for (let x = 0; x <= w; x += step) {
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, h);
        }
        for (let y = 0; y <= h; y += step) {
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(w, y + 0.5);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Circles
        const t = timeMs * 0.001;
        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];

          const px = c.x * w + Math.sin(t * 0.7 + i) * 4.0;
          const py = c.y * h + Math.cos(t * 0.8 + i * 1.3) * 4.0;
          const r = c.r * (0.75 + 0.25 * Math.sin(t * 0.9 + i * 0.4));

          ctx.beginPath();
          ctx.fillStyle = `hsla(${c.hue}, 80%, 60%, ${c.a})`;
          ctx.arc(px, py, r, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalAlpha = 0.25;
          ctx.strokeStyle = "rgba(255,255,255,0.75)";
          ctx.lineWidth = 1.0;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // Cursor marker (warps too)
        if (mouse.has) {
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.strokeStyle = "rgba(255,255,255,0.9)";
          ctx.lineWidth = 2.0;
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        readout.textContent = `sigma=${sigmaPx.toFixed(
          0
        )}px, amp=${ampPx.toFixed(0)}px`;
      }

      // ============================================================
      // Render loop
      // ============================================================
      function frame(timeMs) {
        resize();
        drawScene2D(timeMs);

        // Upload scene to texture
        gl.bindTexture(gl.TEXTURE_2D, sceneTex);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          scene
        );

        // Warp pass
        gl.useProgram(prog);

        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.enableVertexAttribArray(a_pos);
        gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, sceneTex);
        gl.uniform1i(u_scene, 0);

        gl.uniform2f(u_resolution, glCanvas.width, glCanvas.height);

        if (mouse.has) {
          gl.uniform2f(u_mousePx, mouse.x, mouse.y);
          gl.uniform1f(u_enabled, 1.0);
        } else {
          gl.uniform2f(u_mousePx, 0.0, 0.0);
          gl.uniform1f(u_enabled, 0.0);
        }

        gl.uniform1f(u_ampPx, ampPx);
        gl.uniform1f(u_sigmaPx, sigmaPx);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    </script>
  </body>
</html>
